<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>tutorial on Svetlin Ralchev | Blog</title><link>http://blog.ralch.com/categories/tutorial/</link><description>Recent content in tutorial on Svetlin Ralchev | Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 10 Mar 2016 08:52:29 +0000</lastBuildDate><atom:link href="http://blog.ralch.com/categories/tutorial/index.xml" rel="self" type="application/rss+xml"/><item><title>Errors handling in Golang</title><link>http://blog.ralch.com/articles/golang-handling-errors/</link><pubDate>Thu, 10 Mar 2016 08:52:29 +0000</pubDate><guid>http://blog.ralch.com/articles/golang-handling-errors/</guid><description>Go does not have an Exception handling model as most of the main stream languages. However, it uses the error interface type as the return type for any error that is going to be returned from a function or method:
type error interface { Error() string } It is an interface type. An error variable represents any value that can describe itself as a string. The most commonly-used error implementation is in the errors package.</description></item><item><title>Develop code generation tool for Golang</title><link>http://blog.ralch.com/articles/golang-code-generation-tool-implementation/</link><pubDate>Sat, 31 Oct 2015 08:41:39 +0100</pubDate><guid>http://blog.ralch.com/articles/golang-code-generation-tool-implementation/</guid><description>In my previous blog post, we discussed one of my favourite code generation tools for Go. We found that they can be used to automate our trivial development tasks or even introduce features like generics and queries. Lets explore how to create our own tool.
Introduction The Go generate subcommand is a program that scans for special comments in your Go source code. The comment declares a command that should be executed.</description></item><item><title>Query data with Golang and LINQ</title><link>http://blog.ralch.com/articles/golang-query-data-with-linq/</link><pubDate>Sun, 25 Oct 2015 07:35:49 +0100</pubDate><guid>http://blog.ralch.com/articles/golang-query-data-with-linq/</guid><description>Query langauges provide a set of features to querying, projecting and retrieving data (usually relational data). But how to introduces these standard, easily-learned patterns for querying data?
In this article we will explore Go LINQ packages that bridges the gap between the world of objects and the world of data.
LINQ For first time is introduced by Microsoft in their programming language C#. Its purpose is to bridge the gap between query languages such as SQL and programming languages.</description></item><item><title>Generics in Golang</title><link>http://blog.ralch.com/articles/golang-code-generation-and-generics/</link><pubDate>Sun, 18 Oct 2015 05:00:00 +0100</pubDate><guid>http://blog.ralch.com/articles/golang-code-generation-and-generics/</guid><description>In the article we will take the advantage of [generics] even that they are not first citizen in Go. We will explore gen and genny command line tools.
Gen Gen is a code generation tool that brings some generic query functions. It uses annotations to add this functionality to any structure. The generated code is part of your package and does not have any external dependencies. This approach avoids any reflection and produces an efficient concrete implementation for any annotated type.</description></item><item><title>Reusing source code with Go templates</title><link>http://blog.ralch.com/articles/golang-code-generation-with-gotemplates/</link><pubDate>Sun, 11 Oct 2015 20:42:57 +0100</pubDate><guid>http://blog.ralch.com/articles/golang-code-generation-with-gotemplates/</guid><description>In one of my previous blog posts, we discovered go generate command line tool. Lets take the next step and evaluate its advanced benefits to generate a source code by using our own templates. We will explore gotemplate command line tool.
Overview This command line tool manages package based Go templates using go generate. By default it provides a set of templates that can be used out of the box:</description></item><item><title>Golang code generation</title><link>http://blog.ralch.com/articles/golang-code-generation/</link><pubDate>Sun, 04 Oct 2015 08:49:59 +0100</pubDate><guid>http://blog.ralch.com/articles/golang-code-generation/</guid><description>Programs that produce source code are important elements in software engineering. Since Go 1.4, the language ecosystem includes a command line tool that makes it easier to run such tools.
It&amp;rsquo;s called go generate. It scans for special comments in Go source code that identify general commands to run:
//go:generate &amp;lt;subcommand&amp;gt; &amp;lt;arguments&amp;gt; Go generate is not part of go build. It does not do dependency analysis and must be run explicitly before running go build.</description></item><item><title>Golang: Working with Gzip and Tar</title><link>http://blog.ralch.com/articles/golang-working-with-tar-and-gzip/</link><pubDate>Sun, 27 Sep 2015 14:58:56 +0100</pubDate><guid>http://blog.ralch.com/articles/golang-working-with-tar-and-gzip/</guid><description>Gzip Gzip is another file compression format that was created to replace the compress program used in early unix system. It is normally used to compress just single files. Compressed archives are created by packaging collections of files into a single tar archive, and then compressing that archive with gzip. The final .tar.gz or .tgz file is a tarball.
Compressing a file Compressing operation is very simple to implement. The package exposes gzip.</description></item><item><title>Golang: Working with ZIP archives</title><link>http://blog.ralch.com/articles/golang-working-with-zip/</link><pubDate>Sun, 20 Sep 2015 14:58:56 +0100</pubDate><guid>http://blog.ralch.com/articles/golang-working-with-zip/</guid><description>Golang has several packages that work with different type of archives. In this post I will show you how to use archive/zip package to compress and uncompress zip archives.
Zip is one of the most common file formats. It supports lossless data compression of one ore more files and directories.
Extracting You can read the content of zip package by using zip reader. Its File property exposes all files and directories of particular zip package.</description></item><item><title>Golang code inspection tools</title><link>http://blog.ralch.com/articles/golang-tools-inspection/</link><pubDate>Sun, 13 Sep 2015 08:55:41 +0100</pubDate><guid>http://blog.ralch.com/articles/golang-tools-inspection/</guid><description>As a software engineer, you always try to improve the quality of your programs. We are looking for the best software development practices and TDD techniques.
&amp;quot;Have no fear of perfection - you'll never reach it.&amp;quot; ― Salvador Dalí In this article we will explore different code inspection tools in Go ecosystem. We will increase our code quality and engineering skills by running tools that will do analysis on our code base and report the suspicious parts of it.</description></item><item><title>Golang code comprehension tools</title><link>http://blog.ralch.com/articles/golang-tools-comprehension/</link><pubDate>Sun, 06 Sep 2015 08:52:51 +0100</pubDate><guid>http://blog.ralch.com/articles/golang-tools-comprehension/</guid><description>Software engineers spend a greater part of time reading and understanding programs. Indeed, most of the time it takes to develop a program is spent reading it and making logical conclusion about what it does.
Go programmers are no exception. Thanks to gofmt they should not worry about source code formatting. The machines are better suited to analyse source code and accomplish comprehension tasks than us.
In this article we will explore several of Go comprehension tools that are responsible for locating definitions, ascertaining types of expressions, deducing implementation relation, computing method sets, finding callers/callees, jumping through channels, understanding aliasing.</description></item><item><title>Golang refactoring tools</title><link>http://blog.ralch.com/articles/golang-tools-refactoring/</link><pubDate>Sun, 30 Aug 2015 12:41:34 +0100</pubDate><guid>http://blog.ralch.com/articles/golang-tools-refactoring/</guid><description>Go language provides many useful tools as part of its development eco system. We will explore most of them in the upcoming blog posts. But in the article lets focus on refactoring tools.
Gofmt In average programming languages developers can adapt to different formatting styles. Common problem is how to approach unknown code base without a long prescriptive style guide.
Go takes an unusual approach and keep this responsibility to format the source code for you.</description></item><item><title>Sharing Golang packages to C and Go</title><link>http://blog.ralch.com/articles/golang-sharing-libraries/</link><pubDate>Sun, 23 Aug 2015 11:04:50 +0100</pubDate><guid>http://blog.ralch.com/articles/golang-sharing-libraries/</guid><description>The latest Go 1.5 version is out. As part of the new features, Go compiler can compile packages as a shared libraries.
It accepts -buildmode argument that determines how a package is compiled. These are the following options:
archive: Build the listed non-main packages into .a files. Packages named main are ignored. c-archive: Build the listed main package, plus all packages it imports, into a C archive file. c-shared: Build the listed main packages, plus all packages that they import, into C shared libraries.</description></item><item><title>Conditional compilation in Golang</title><link>http://blog.ralch.com/articles/golang-conditional-compilation/</link><pubDate>Sun, 16 Aug 2015 08:40:35 +0100</pubDate><guid>http://blog.ralch.com/articles/golang-conditional-compilation/</guid><description>When developing Go package or application that depends on specific features of the underlying platform or architecture it is often necessary to use a specialised implementation.
There are two parts of Go conditional compilation system, which we will now explore in more detail.
Build constraints A build constraints (known as build tags) is an optional top line comment that starts with
// +build package api Declaration of build constraints follows the following rules:</description></item><item><title>Delve: Next generation debugger for Golang</title><link>http://blog.ralch.com/articles/golang-debug-with-delve/</link><pubDate>Sat, 08 Aug 2015 20:42:49 +0100</pubDate><guid>http://blog.ralch.com/articles/golang-debug-with-delve/</guid><description>In my previous post I demonstrated how you can debug golang applications with LLDB. In this article I will illustrate the most recent debugger for Go: Delve
The debugger is a community effort to bring a debugger in the toolchain of every Go developer.
It&amp;rsquo;s written in Go to debug Go code. It&amp;rsquo;s still in active development, but we can still benefit from its basic features.
Installation You should install Delve with the following command:</description></item><item><title>Debug Golang applications: LLDB</title><link>http://blog.ralch.com/articles/golang-debug-with-lldb/</link><pubDate>Sat, 01 Aug 2015 16:47:06 +0100</pubDate><guid>http://blog.ralch.com/articles/golang-debug-with-lldb/</guid><description>Even that ease and simplicity of using go are one of its main advanatages, there are difficulties in debugging applications written in go.
The lack of mature tools (like supported vim plugin) push most of us to use logging techniques to inspect and track down issues.
In this article, I will demonstrates how you can use vim and lldb to debug a go application. Before that you should make the application capable for debugging.</description></item><item><title>SSH tunneling in Golang</title><link>http://blog.ralch.com/articles/golang-ssh-tunneling/</link><pubDate>Sun, 26 Jul 2015 08:00:00 +0100</pubDate><guid>http://blog.ralch.com/articles/golang-ssh-tunneling/</guid><description>In my previous post, I illustrated the basic usage of ssh package. In this article I will demonstrate how we should use it to implement SSH tunneling. We will forward connection to localhost:9000 through example.com:22 to localhost:8080.
The tunneling protocol allows a network user to access or provide a network service that the underlying network does not support or provide directly.
We have four actors in this scenario:
client - the client that needs resource from remote server local server - a server accessible by the client intermediate server - a server accessible by the local server and remote/target server remote/target server - a server running behind the intermediate server network Each of this server endpoints can be represented by the following struct:</description></item><item><title>SSH Client connection in Golang</title><link>http://blog.ralch.com/articles/golang-ssh-connection/</link><pubDate>Sat, 18 Jul 2015 11:26:07 +0100</pubDate><guid>http://blog.ralch.com/articles/golang-ssh-connection/</guid><description>SSH is a network protocol for establishing a secure shell session on distant servers. In Golang the package godoc.org/golang.org/x/crypto/ssh implements SSH client and SSH server.
In this article, we are using SSH client to run a shell command on a remote machine. Every SSH connection requires an ssh.CleintConfig object that defines configuration options such as authentication.
Authentication Options Depending on how the remote server is configure, there are two ways to authenticate:</description></item><item><title>Golang: Pipes and redirection in command line applications</title><link>http://blog.ralch.com/articles/golang-command-line-pipes/</link><pubDate>Sat, 11 Jul 2015 11:58:15 +0100</pubDate><guid>http://blog.ralch.com/articles/golang-command-line-pipes/</guid><description>Powerful features of the Linux command line shell are redirection and pipes that allow the output and even input of a program to be sent to a file or another program.
In this article, I will demonstrates how we can pipe a file into a go application.
Pipes Pipes allow you to funnel the output from one command into another where it will be used as the input. We should use | symbol to redirect the output.</description></item><item><title>Golang: Using user defined type as flag in terminal applications</title><link>http://blog.ralch.com/articles/golang-custom-flags/</link><pubDate>Mon, 06 Jul 2015 21:11:59 +0100</pubDate><guid>http://blog.ralch.com/articles/golang-custom-flags/</guid><description>As we saw in the previous article the flag package gives us flexibility to develop command-line applications that suite our needs.
In this post, I will show how you can develop a flag argument for user defined type.
Lets develop application that should be executed in the following ways:
healthcheck -url=http://www.example.com,http://mail.example.com/inbox healthcheck -url=http://www.example.com -url=http://mail.example.com/inbox We can use the predefined url.URL struct in net/url package as type of the arguments that are expected.</description></item><item><title>Golang: Implementing subcommands for command line applications</title><link>http://blog.ralch.com/articles/golang-subcommands/</link><pubDate>Sat, 04 Jul 2015 14:08:25 +0100</pubDate><guid>http://blog.ralch.com/articles/golang-subcommands/</guid><description>Golang flag package provides flag and subcommand parsing of command line arguments.
Basic flags are available for most of the buildin data types (string, integer, boolean and time.Duration). To declare a string flag username with a default value root and short description, you should use the following code:
package main import &amp;quot;flag&amp;quot; import &amp;quot;fmt&amp;quot; func main() { username := flag.String(&amp;quot;user&amp;quot;, &amp;quot;root&amp;quot;, &amp;quot;Username for this server&amp;quot;) flag.Parse() fmt.Printf(&amp;quot;Your username is %q.&amp;quot;, *username) } Once all flags are declared, call flag.</description></item><item><title>SSL support for Busybox docker containers</title><link>http://blog.ralch.com/articles/devop-busybox-ca-certificates/</link><pubDate>Thu, 23 Apr 2015 21:50:49 +0100</pubDate><guid>http://blog.ralch.com/articles/devop-busybox-ca-certificates/</guid><description>I am running my official website and this blog on busybox docker containers. I noticed today that this image does not support certificate trust stores and therefore cannot request an SSL-enabled web services.
My website is using Google recaptcha to handle spam requests on its contact form. However, the website throws the following exception when recaptch API is requested:
x509: failed to load system roots and no roots provided
First approach would be to use COPY command to load the certificate store bundle in to the image.</description></item></channel></rss>