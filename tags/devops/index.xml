<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>devops on Svetlin Ralchev</title><link>http://blog.ralch.com/tags/devops/</link><description>Recent content in devops on Svetlin Ralchev</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 26 Jul 2015 08:00:00 +0100</lastBuildDate><atom:link href="http://blog.ralch.com/tags/devops/index.xml" rel="self" type="application/rss+xml"/><item><title>SSH tunneling in Golang</title><link>http://blog.ralch.com/articles/golang-ssh-tunneling/</link><pubDate>Sun, 26 Jul 2015 08:00:00 +0100</pubDate><guid>http://blog.ralch.com/articles/golang-ssh-tunneling/</guid><description>In my previous post, I illustrated the basic usage of ssh package. In this article I will demonstrate how we should use it to implement SSH tunneling. We will forward connection to localhost:9000 through example.com:22 to localhost:8080.
The tunneling protocol allows a network user to access or provide a network service that the underlying network does not support or provide directly.
We have four actors in this scenario:
client - the client that needs resource from remote server local server - a server accessible by the client intermediate server - a server accessible by the local server and remote/target server remote/target server - a server running behind the intermediate server network Each of this server endpoints can be represented by the following struct:</description></item></channel></rss>