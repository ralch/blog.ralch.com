<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>structural design patterns on Svetlin Ralchev | Blog</title><link>http://blog.ralch.com/tags/structural-design-patterns/</link><description>Recent content in structural design patterns on Svetlin Ralchev | Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>(c) 2021 Svetlin Ralchev</copyright><lastBuildDate>Sun, 17 Apr 2016 18:33:52 +0100</lastBuildDate><atom:link href="http://blog.ralch.com/tags/structural-design-patterns/index.xml" rel="self" type="application/rss+xml"/><item><title>Design Patterns in Golang: Decorator</title><link>http://blog.ralch.com/articles/design-patterns/golang-decorator/</link><pubDate>Sun, 17 Apr 2016 18:33:52 +0100</pubDate><guid>http://blog.ralch.com/articles/design-patterns/golang-decorator/</guid><description>Introduction The Decorator pattern adds new functionality to an existing object without altering its structure. It is a structural pattern as this pattern acts as a wrapper to existing class.
The instanciate a decorator struct which decorates (wraps) the original object and provides additional functionality keeping its methods signature intact.
Purpose Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to inheritance for extending functionality. Wrapping a present, putting it in a box, and wrapping the box.</description></item><item><title>Design Patterns in Golang: Composite</title><link>http://blog.ralch.com/articles/design-patterns/golang-composite/</link><pubDate>Thu, 31 Mar 2016 09:00:27 +0100</pubDate><guid>http://blog.ralch.com/articles/design-patterns/golang-composite/</guid><description>Introduction A Composite Design Pattern is a structural pattern that uses to employ composition when implementing an interface rather than using multiple inheritance. It composes objects into tree structures and lets clients treat individual objects and compositions uniformly.
There are situations when clients ignore the difference between compositions of objects and individual objects. If dealing with multiple objects in the same way as handle each of deam is identical, the Composite Design pattern is a good choice to decrease the complexity and treat them as homogeneous.</description></item><item><title>Design Patterns in Golang: Adapter</title><link>http://blog.ralch.com/articles/design-patterns/golang-adapter/</link><pubDate>Mon, 22 Feb 2016 08:42:38 +0000</pubDate><guid>http://blog.ralch.com/articles/design-patterns/golang-adapter/</guid><description>Introduction The Adapter Pattern is responsible for adaptation of two incompatible interfaces. It is a structural pattern that is responsible to join functionalities of independent or incompatible interfaces without modifing their implementation.
Interfaces may be incompatible but the inner functionality should suit the need. It allows otherwise incompatible objects to work together by converting the interface of each struct into an interface expected by the clients.
Purpose Impedance match an old component to a new system Wrap the interface of a object into another interface clients expect.</description></item></channel></rss>