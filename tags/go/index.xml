<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>go on Svetlin Ralchev | Blog</title><link>http://blog.ralch.com/tags/go/</link><description>Recent content in go on Svetlin Ralchev | Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>(c) 2023 Svetlin Ralchev</copyright><lastBuildDate>Mon, 25 Sep 2017 16:28:10 +0100</lastBuildDate><atom:link href="http://blog.ralch.com/tags/go/index.xml" rel="self" type="application/rss+xml"/><item><title>Advanced Error Handling in Golang</title><link>http://blog.ralch.com/articles/advanced-error-handling-in-golang/</link><pubDate>Mon, 25 Sep 2017 16:28:10 +0100</pubDate><guid>http://blog.ralch.com/articles/advanced-error-handling-in-golang/</guid><description>If you have ever written any Golang code you have probably noticed the built-in error type interface. Golang uses error values to indicate an abnormal state. The error type represents any value that can describe itself as a string. Here is the interface&amp;rsquo;s declaration:
type error interface { Error() string } The most commonly-used error implementation is the errors package&amp;rsquo;s implementation that allows you to instantiate errors by using the following code snippet:</description></item><item><title>Network Programming and Proxies in Golang</title><link>http://blog.ralch.com/articles/network-programming-and-proxies-in-golang/</link><pubDate>Tue, 22 Aug 2017 14:17:48 +0100</pubDate><guid>http://blog.ralch.com/articles/network-programming-and-proxies-in-golang/</guid><description>Learn how to use Proxy to establish TCP connections in Golang</description></item><item><title>Golang: Extending reflect.StructTag to support duplicates</title><link>http://blog.ralch.com/articles/golang-reflect-struct-tag/</link><pubDate>Tue, 21 Mar 2017 12:33:56 +0100</pubDate><guid>http://blog.ralch.com/articles/golang-reflect-struct-tag/</guid><description>Presently, Golang has limited support of reflection comparing to the mainstream languages like C# and JAVA. It&amp;rsquo;s not intended to match or beat that languages.
In practice, we are using StructTag to add some metadata for the defined struct fields. Such an example is json package, where you can customize the field marshaling.
In example below, we customize the json representation of User struct fields:
type User struct { ID string `json:&amp;#34;id&amp;#34;` Name string `json:&amp;#34;name&amp;#34;` CreatedAt time.</description></item><item><title>Design Patterns in Golang: Decorator</title><link>http://blog.ralch.com/articles/design-patterns/golang-decorator/</link><pubDate>Sun, 17 Apr 2016 18:33:52 +0100</pubDate><guid>http://blog.ralch.com/articles/design-patterns/golang-decorator/</guid><description>Introduction The Decorator pattern adds new functionality to an existing object without altering its structure. It is a structural pattern as this pattern acts as a wrapper to existing class.
The instanciate a decorator struct which decorates (wraps) the original object and provides additional functionality keeping its methods signature intact.
Purpose Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to inheritance for extending functionality. Wrapping a present, putting it in a box, and wrapping the box.</description></item><item><title>Design Patterns in Golang: Composite</title><link>http://blog.ralch.com/articles/design-patterns/golang-composite/</link><pubDate>Thu, 31 Mar 2016 09:00:27 +0100</pubDate><guid>http://blog.ralch.com/articles/design-patterns/golang-composite/</guid><description>Introduction A Composite Design Pattern is a structural pattern that uses to employ composition when implementing an interface rather than using multiple inheritance. It composes objects into tree structures and lets clients treat individual objects and compositions uniformly.
There are situations when clients ignore the difference between compositions of objects and individual objects. If dealing with multiple objects in the same way as handle each of deam is identical, the Composite Design pattern is a good choice to decrease the complexity and treat them as homogeneous.</description></item><item><title>Desing Patterns in Golang: Bridge</title><link>http://blog.ralch.com/articles/design-patterns/golang-bridge/</link><pubDate>Thu, 17 Mar 2016 17:26:46 +0000</pubDate><guid>http://blog.ralch.com/articles/design-patterns/golang-bridge/</guid><description>Introduction The Bridge Pattern is a creational design pattern used to decouple an abstraction from its implementation. The bridge uses encapsulation, aggregation, and can use inheritance to separate responsibilities into different classes.
Purpose Decouple an abstraction from its implementation that allows both to vary independently. Publish interface in an inheritance hierarchy, and bury implementation in its own inheritance hierarchy. Design Pattern Diagram The objects participating in this pattern are presented on the following diagram:</description></item><item><title>Errors handling in Golang</title><link>http://blog.ralch.com/articles/golang-handling-errors/</link><pubDate>Thu, 10 Mar 2016 08:52:29 +0000</pubDate><guid>http://blog.ralch.com/articles/golang-handling-errors/</guid><description>Go does not have an Exception handling model as most of the main stream languages. However, it uses the error interface type as the return type for any error that is going to be returned from a function or method:
type error interface { Error() string } It is an interface type. An error variable represents any value that can describe itself as a string. The most commonly-used error implementation is in the errors package.</description></item><item><title>Design Patterns in Golang: Adapter</title><link>http://blog.ralch.com/articles/design-patterns/golang-adapter/</link><pubDate>Mon, 22 Feb 2016 08:42:38 +0000</pubDate><guid>http://blog.ralch.com/articles/design-patterns/golang-adapter/</guid><description>Introduction The Adapter Pattern is responsible for adaptation of two incompatible interfaces. It is a structural pattern that is responsible to join functionalities of independent or incompatible interfaces without modifing their implementation.
Interfaces may be incompatible but the inner functionality should suit the need. It allows otherwise incompatible objects to work together by converting the interface of each struct into an interface expected by the clients.
Purpose Impedance match an old component to a new system Wrap the interface of a object into another interface clients expect.</description></item><item><title>Design Patterns in Golang: Prototype</title><link>http://blog.ralch.com/articles/design-patterns/golang-prototype/</link><pubDate>Sat, 06 Feb 2016 16:01:29 +0000</pubDate><guid>http://blog.ralch.com/articles/design-patterns/golang-prototype/</guid><description>Preface The Prototype Pattern creates duplicate objects while keeping performance in mind. It&amp;rsquo;s a part of the creational patterns and provides one of the best ways to create an object.
In the mainstream languages (like C# and JAVA), it requires implementing a prototype interface which tells to create a clone of the current object. It is used when creation of object directly is costly.
For instance, an object is to be created after a costly database operation.</description></item><item><title>Design Patterns in Golang: The Good, the Bad and the Ugly</title><link>http://blog.ralch.com/articles/design-patterns/golang-design-patterns/</link><pubDate>Wed, 03 Feb 2016 13:34:23 +0000</pubDate><guid>http://blog.ralch.com/articles/design-patterns/golang-design-patterns/</guid><description>Recently I started a series of articles about Gang of Four Design Patterns and their adoption in Golang. They made a lot of noise in the community. I read a lot of contradictionary opionions whether should be used or not. I am publishing those articles as show case how the common design patterns can be adopted and implemented in Golang. I don&amp;rsquo;t encourage or promote their usage. Every developer has own style of programming, architecture desing and problem solving solutions.</description></item><item><title>Desing Patterns in Golang: Factory Method</title><link>http://blog.ralch.com/articles/design-patterns/golang-factory-method/</link><pubDate>Sun, 31 Jan 2016 08:46:53 +0000</pubDate><guid>http://blog.ralch.com/articles/design-patterns/golang-factory-method/</guid><description>Introduction The Factory Method pattern is a design pattern used to define a runtime interface for creating an object. Itâ€™s called a factory because it creates various types of objects without necessarily knowing what kind of object it creates or how to create it.
Purpose Allows the sub-classes to choose the type of objects to create at runtime It provides a simple way of extending the family of objects with minor changes in application code.</description></item><item><title>Desing Patterns in Golang: Builder</title><link>http://blog.ralch.com/articles/design-patterns/golang-builder/</link><pubDate>Sun, 24 Jan 2016 08:46:53 +0000</pubDate><guid>http://blog.ralch.com/articles/design-patterns/golang-builder/</guid><description>Introduction The Builder Pattern is a creational design pattern that&amp;rsquo;s used to encapsulate the construction logic for an object. It is often used when the construction process of an object is complex. The patterns is well suited for constructing different representations of the same class.
Purpose Separate the construction of a complex object from its representation so that the same construction process can create different representations. A common software creational design pattern that&amp;rsquo;s used to encapsulate the construction logic for an object.</description></item><item><title>Design Patterns in Golang: Singleton</title><link>http://blog.ralch.com/articles/design-patterns/golang-singleton/</link><pubDate>Sun, 17 Jan 2016 13:35:05 +0000</pubDate><guid>http://blog.ralch.com/articles/design-patterns/golang-singleton/</guid><description>Introduction Sometimes it&amp;rsquo;s important to have only one instance of an struct. This is useful when exactly one object is needed to coordinate actions across the system. Singletons provide a global point of access to themselves.
The singleton pattern is one of the simplest design patterns. It requires only one type which is responsible to instantiate itself, to make sure it creates not more than one instance. The same instance can be used from everywhere.</description></item><item><title>Serialization objects with protocol buffers in Golang</title><link>http://blog.ralch.com/articles/golang-proto-buffer/</link><pubDate>Tue, 12 Jan 2016 08:02:19 +0000</pubDate><guid>http://blog.ralch.com/articles/golang-proto-buffer/</guid><description>What is protocol buffers? Protocol Buffers is a method of serializing structured data. It is useful in developing programs to communicate with each other over a wire or for storing data. The method involves an interface description language that describes the structure of some data and a program that generates source code from that description for generating or parsing a stream of bytes that represents the structured data.
Google developed Protocol Buffers for use internally and has made protocol compilers for C++, Java and Python available to the public under a free software, open source license.</description></item><item><title>Reflection in Golang</title><link>http://blog.ralch.com/articles/golang-reflection/</link><pubDate>Mon, 21 Dec 2015 08:15:16 +0000</pubDate><guid>http://blog.ralch.com/articles/golang-reflection/</guid><description>What is reflection? In computer science, reflection is the ability of a computer program to examine and modify its own structure and behavior (specifically the values, meta-data, properties and functions) at runtime.
source: Wikipedia
Reflection can be used for observing and modifying program execution at runtime. A reflection-oriented program component can monitor the execution of an enclosure of code and can modify itself according to a desired goal related to that enclosure.</description></item><item><title>Performance and memory analysis of Golang programs</title><link>http://blog.ralch.com/articles/golang-performance-and-memory-analysis/</link><pubDate>Sun, 13 Dec 2015 13:39:32 +0000</pubDate><guid>http://blog.ralch.com/articles/golang-performance-and-memory-analysis/</guid><description>As we continue looking at program metrics in Golang, it is time to look at performance matrics analysis.
Instrumentation Instrumentation is the process of adding code to your application to generate events to allow you to monitor application health and performance. Instrumentation allows you to profile applications. Profiling enables you to identify how long a particular method or operation takes to run and how efficient it is in terms of CPU and memory resource usage.</description></item><item><title>Expose application metrics with expvar</title><link>http://blog.ralch.com/articles/golang-metrics-with-expvar/</link><pubDate>Sun, 06 Dec 2015 08:47:15 +0000</pubDate><guid>http://blog.ralch.com/articles/golang-metrics-with-expvar/</guid><description>To determine whether your application meets its performance objectives and to help identify bottlenecks, you need to measure your program&amp;rsquo;s performance and collect metrics. They tend to be response time, throughput, and resource utilization (how much CPU, memory, disk I/O, and network bandwidth your application consumes while performing its tasks).
Metrics Metrics provide information about how close your program is to your performance goals. In addition, they also help you identify problem areas and bottlenecks within your application.</description></item><item><title>Concurrent patterns in Golang: Context</title><link>http://blog.ralch.com/articles/golang-concurrency-patterns-context/</link><pubDate>Sun, 29 Nov 2015 08:50:48 +0000</pubDate><guid>http://blog.ralch.com/articles/golang-concurrency-patterns-context/</guid><description>What is concurrency? Concurrent applications have multiple computations executing during overlapping periods of time. Respectively sequential programs in which no computations can be executed in overlapping periods of time.
Getting started with Context package The Context package is responsible for signal cancelation and operation deadlines for processes and server requests.
The package has an context.Context interface:
type Context interface { Deadline() (deadline time.Time, ok bool) Done() &amp;lt;-chan struct{} Err() error Value(key interface{}) interface{} } The interface provides four functions to observe the context state:</description></item><item><title>Data validation in Golang</title><link>http://blog.ralch.com/articles/golang-model-validation/</link><pubDate>Sun, 22 Nov 2015 19:28:31 +0000</pubDate><guid>http://blog.ralch.com/articles/golang-model-validation/</guid><description>Almost every application requires high data integrirty and quality. Very likely is its algorithms to behave weird and produce unexpected results due to invalid input.
An important aspect of software development is data validation. In this article we will explore govalidate package that helps us to validate and sanitize any string, struct and slice in Go.
The package itself is very infulenced by its javascript predaccessor validator.js.
Installation Like any other Go package we should install it first:</description></item><item><title>Embedded resources in Golang</title><link>http://blog.ralch.com/articles/golang-embedded-resources/</link><pubDate>Sun, 08 Nov 2015 08:35:11 +0000</pubDate><guid>http://blog.ralch.com/articles/golang-embedded-resources/</guid><description>What&amp;rsquo;s an Embedded Resource? An embedded resource in a application is a file that is included as part of the application. The file is not compiled, but is accessable from the code at run-time. Embedded resources can be any file type.
Languages as JAVA and C# support resources out of box. However, this is not the case for Golang. In order to emebed resource, we need to develop our own solution.</description></item><item><title>Develop code generation tool for Golang</title><link>http://blog.ralch.com/articles/golang-code-generation-tool-implementation/</link><pubDate>Sat, 31 Oct 2015 08:41:39 +0100</pubDate><guid>http://blog.ralch.com/articles/golang-code-generation-tool-implementation/</guid><description>In my previous blog post, we discussed one of my favourite code generation tools for Go. We found that they can be used to automate our trivial development tasks or even introduce features like generics and queries. Lets explore how to create our own tool.
Introduction The Go generate subcommand is a program that scans for special comments in your Go source code. The comment declares a command that should be executed.</description></item><item><title>Query data with Golang and LINQ</title><link>http://blog.ralch.com/articles/golang-query-data-with-linq/</link><pubDate>Sun, 25 Oct 2015 07:35:49 +0100</pubDate><guid>http://blog.ralch.com/articles/golang-query-data-with-linq/</guid><description>Query langauges provide a set of features to querying, projecting and retrieving data (usually relational data). But how to introduces these standard, easily-learned patterns for querying data?
In this article we will explore Go LINQ packages that bridges the gap between the world of objects and the world of data.
LINQ For first time is introduced by Microsoft in their programming language C#. Its purpose is to bridge the gap between query languages such as SQL and programming languages.</description></item><item><title>Generics in Golang</title><link>http://blog.ralch.com/articles/golang-code-generation-and-generics/</link><pubDate>Sun, 18 Oct 2015 05:00:00 +0100</pubDate><guid>http://blog.ralch.com/articles/golang-code-generation-and-generics/</guid><description>In the article we will take the advantage of [generics] even that they are not first citizen in Go. We will explore gen and genny command line tools.
Gen Gen is a code generation tool that brings some generic query functions. It uses annotations to add this functionality to any structure. The generated code is part of your package and does not have any external dependencies. This approach avoids any reflection and produces an efficient concrete implementation for any annotated type.</description></item><item><title>Reusing source code with Go templates</title><link>http://blog.ralch.com/articles/golang-code-generation-with-gotemplates/</link><pubDate>Sun, 11 Oct 2015 20:42:57 +0100</pubDate><guid>http://blog.ralch.com/articles/golang-code-generation-with-gotemplates/</guid><description>In one of my previous blog posts, we discovered go generate command line tool. Lets take the next step and evaluate its advanced benefits to generate a source code by using our own templates. We will explore gotemplate command line tool.
Overview This command line tool manages package based Go templates using go generate. By default it provides a set of templates that can be used out of the box:</description></item><item><title>Golang code generation</title><link>http://blog.ralch.com/articles/golang-code-generation/</link><pubDate>Sun, 04 Oct 2015 08:49:59 +0100</pubDate><guid>http://blog.ralch.com/articles/golang-code-generation/</guid><description>Programs that produce source code are important elements in software engineering. Since Go 1.4, the language ecosystem includes a command line tool that makes it easier to run such tools.
It&amp;rsquo;s called go generate. It scans for special comments in Go source code that identify general commands to run:
//go:generate &amp;lt;subcommand&amp;gt; &amp;lt;arguments&amp;gt; Go generate is not part of go build. It does not do dependency analysis and must be run explicitly before running go build.</description></item><item><title>Golang: Working with Gzip and Tar</title><link>http://blog.ralch.com/articles/golang-working-with-tar-and-gzip/</link><pubDate>Sun, 27 Sep 2015 14:58:56 +0100</pubDate><guid>http://blog.ralch.com/articles/golang-working-with-tar-and-gzip/</guid><description>Gzip Gzip is another file compression format that was created to replace the compress program used in early unix system. It is normally used to compress just single files. Compressed archives are created by packaging collections of files into a single tar archive, and then compressing that archive with gzip. The final .tar.gz or .tgz file is a tarball.
Compressing a file Compressing operation is very simple to implement. The package exposes gzip.</description></item><item><title>Golang: Working with ZIP archives</title><link>http://blog.ralch.com/articles/golang-working-with-zip/</link><pubDate>Sun, 20 Sep 2015 14:58:56 +0100</pubDate><guid>http://blog.ralch.com/articles/golang-working-with-zip/</guid><description>Golang has several packages that work with different type of archives. In this post I will show you how to use archive/zip package to compress and uncompress zip archives.
Zip is one of the most common file formats. It supports lossless data compression of one ore more files and directories.
Extracting You can read the content of zip package by using zip reader. Its File property exposes all files and directories of particular zip package.</description></item><item><title>Golang code inspection tools</title><link>http://blog.ralch.com/articles/golang-tools-inspection/</link><pubDate>Sun, 13 Sep 2015 08:55:41 +0100</pubDate><guid>http://blog.ralch.com/articles/golang-tools-inspection/</guid><description>As a software engineer, you always try to improve the quality of your programs. We are looking for the best software development practices and TDD techniques.
&amp;#34;Have no fear of perfection - you&amp;#39;ll never reach it.&amp;#34; â€• Salvador DalÃ­ In this article we will explore different code inspection tools in Go ecosystem. We will increase our code quality and engineering skills by running tools that will do analysis on our code base and report the suspicious parts of it.</description></item><item><title>Golang code comprehension tools</title><link>http://blog.ralch.com/articles/golang-tools-comprehension/</link><pubDate>Sun, 06 Sep 2015 08:52:51 +0100</pubDate><guid>http://blog.ralch.com/articles/golang-tools-comprehension/</guid><description>Software engineers spend a greater part of time reading and understanding programs. Indeed, most of the time it takes to develop a program is spent reading it and making logical conclusion about what it does.
Go programmers are no exception. Thanks to gofmt they should not worry about source code formatting. The machines are better suited to analyse source code and accomplish comprehension tasks than us.
In this article we will explore several of Go comprehension tools that are responsible for locating definitions, ascertaining types of expressions, deducing implementation relation, computing method sets, finding callers/callees, jumping through channels, understanding aliasing.</description></item><item><title>Golang refactoring tools</title><link>http://blog.ralch.com/articles/golang-tools-refactoring/</link><pubDate>Sun, 30 Aug 2015 12:41:34 +0100</pubDate><guid>http://blog.ralch.com/articles/golang-tools-refactoring/</guid><description>Go language provides many useful tools as part of its development eco system. We will explore most of them in the upcoming blog posts. But in the article lets focus on refactoring tools.
Gofmt In average programming languages developers can adapt to different formatting styles. Common problem is how to approach unknown code base without a long prescriptive style guide.
Go takes an unusual approach and keep this responsibility to format the source code for you.</description></item><item><title>Sharing Golang packages to C and Go</title><link>http://blog.ralch.com/articles/golang-sharing-libraries/</link><pubDate>Sun, 23 Aug 2015 11:04:50 +0100</pubDate><guid>http://blog.ralch.com/articles/golang-sharing-libraries/</guid><description>The latest Go 1.5 version is out. As part of the new features, Go compiler can compile packages as a shared libraries.
It accepts -buildmode argument that determines how a package is compiled. These are the following options:
archive: Build the listed non-main packages into .a files. Packages named main are ignored. c-archive: Build the listed main package, plus all packages it imports, into a C archive file. c-shared: Build the listed main packages, plus all packages that they import, into C shared libraries.</description></item><item><title>Conditional compilation in Golang</title><link>http://blog.ralch.com/articles/golang-conditional-compilation/</link><pubDate>Sun, 16 Aug 2015 08:40:35 +0100</pubDate><guid>http://blog.ralch.com/articles/golang-conditional-compilation/</guid><description>When developing Go package or application that depends on specific features of the underlying platform or architecture it is often necessary to use a specialised implementation.
There are two parts of Go conditional compilation system, which we will now explore in more detail.
Build constraints A build constraints (known as build tags) is an optional top line comment that starts with
// +build package api Declaration of build constraints follows the following rules:</description></item><item><title>Delve: Next generation debugger for Golang</title><link>http://blog.ralch.com/articles/golang-debug-with-delve/</link><pubDate>Sat, 08 Aug 2015 20:42:49 +0100</pubDate><guid>http://blog.ralch.com/articles/golang-debug-with-delve/</guid><description>In my previous post I demonstrated how you can debug golang applications with LLDB. In this article I will illustrate the most recent debugger for Go: Delve
The debugger is a community effort to bring a debugger in the toolchain of every Go developer.
It&amp;rsquo;s written in Go to debug Go code. It&amp;rsquo;s still in active development, but we can still benefit from its basic features.
Installation You should install Delve with the following command:</description></item><item><title>Debug Golang applications: LLDB</title><link>http://blog.ralch.com/articles/golang-debug-with-lldb/</link><pubDate>Sat, 01 Aug 2015 16:47:06 +0100</pubDate><guid>http://blog.ralch.com/articles/golang-debug-with-lldb/</guid><description>Even that ease and simplicity of using go are one of its main advanatages, there are difficulties in debugging applications written in go.
The lack of mature tools (like supported vim plugin) push most of us to use logging techniques to inspect and track down issues.
In this article, I will demonstrates how you can use vim and lldb to debug a go application. Before that you should make the application capable for debugging.</description></item><item><title>SSH tunneling in Golang</title><link>http://blog.ralch.com/articles/golang-ssh-tunneling/</link><pubDate>Sun, 26 Jul 2015 08:00:00 +0100</pubDate><guid>http://blog.ralch.com/articles/golang-ssh-tunneling/</guid><description>In my previous post, I illustrated the basic usage of ssh package. In this article I will demonstrate how we should use it to implement SSH tunneling. We will forward connection to localhost:9000 through example.com:22 to localhost:8080.
The tunneling protocol allows a network user to access or provide a network service that the underlying network does not support or provide directly.
We have four actors in this scenario:
client - the client that needs resource from remote server local server - a server accessible by the client intermediate server - a server accessible by the local server and remote/target server remote/target server - a server running behind the intermediate server network Each of this server endpoints can be represented by the following struct:</description></item><item><title>SSH Client connection in Golang</title><link>http://blog.ralch.com/articles/golang-ssh-connection/</link><pubDate>Sat, 18 Jul 2015 11:26:07 +0100</pubDate><guid>http://blog.ralch.com/articles/golang-ssh-connection/</guid><description>SSH is a network protocol for establishing a secure shell session on distant servers. In Golang the package godoc.org/golang.org/x/crypto/ssh implements SSH client and SSH server.
In this article, we are using SSH client to run a shell command on a remote machine. Every SSH connection requires an ssh.CleintConfig object that defines configuration options such as authentication.
Authentication Options Depending on how the remote server is configure, there are two ways to authenticate:</description></item><item><title>Golang: Pipes and redirection in command line applications</title><link>http://blog.ralch.com/articles/golang-command-line-pipes/</link><pubDate>Sat, 11 Jul 2015 11:58:15 +0100</pubDate><guid>http://blog.ralch.com/articles/golang-command-line-pipes/</guid><description>Powerful features of the Linux command line shell are redirection and pipes that allow the output and even input of a program to be sent to a file or another program.
In this article, I will demonstrates how we can pipe a file into a go application.
Pipes Pipes allow you to funnel the output from one command into another where it will be used as the input. We should use | symbol to redirect the output.</description></item><item><title>Golang: Using user defined type as flag in terminal applications</title><link>http://blog.ralch.com/articles/golang-custom-flags/</link><pubDate>Mon, 06 Jul 2015 21:11:59 +0100</pubDate><guid>http://blog.ralch.com/articles/golang-custom-flags/</guid><description>As we saw in the previous article the flag package gives us flexibility to develop command-line applications that suite our needs.
In this post, I will show how you can develop a flag argument for user defined type.
Lets develop application that should be executed in the following ways:
healthcheck -url=http://www.example.com,http://mail.example.com/inbox healthcheck -url=http://www.example.com -url=http://mail.example.com/inbox We can use the predefined url.URL struct in net/url package as type of the arguments that are expected.</description></item><item><title>Golang: Implementing subcommands for command line applications</title><link>http://blog.ralch.com/articles/golang-subcommands/</link><pubDate>Sat, 04 Jul 2015 14:08:25 +0100</pubDate><guid>http://blog.ralch.com/articles/golang-subcommands/</guid><description>Golang flag package provides flag and subcommand parsing of command line arguments.
Basic flags are available for most of the buildin data types (string, integer, boolean and time.Duration). To declare a string flag username with a default value root and short description, you should use the following code:
package main import &amp;#34;flag&amp;#34; import &amp;#34;fmt&amp;#34; func main() { username := flag.String(&amp;#34;user&amp;#34;, &amp;#34;root&amp;#34;, &amp;#34;Username for this server&amp;#34;) flag.Parse() fmt.Printf(&amp;#34;Your username is %q.&amp;#34;, *username) } Once all flags are declared, call flag.</description></item></channel></rss>