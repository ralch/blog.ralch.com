<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>concurrency on Svetlin Ralchev | Blog</title><link>http://blog.ralch.com/tags/concurrency/</link><description>Recent content in concurrency on Svetlin Ralchev | Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>(c) 2023 Svetlin Ralchev</copyright><lastBuildDate>Sun, 29 Nov 2015 08:50:48 +0000</lastBuildDate><atom:link href="http://blog.ralch.com/tags/concurrency/index.xml" rel="self" type="application/rss+xml"/><item><title>Concurrent patterns in Golang: Context</title><link>http://blog.ralch.com/articles/golang-concurrency-patterns-context/</link><pubDate>Sun, 29 Nov 2015 08:50:48 +0000</pubDate><guid>http://blog.ralch.com/articles/golang-concurrency-patterns-context/</guid><description>What is concurrency? Concurrent applications have multiple computations executing during overlapping periods of time. Respectively sequential programs in which no computations can be executed in overlapping periods of time.
Getting started with Context package The Context package is responsible for signal cancelation and operation deadlines for processes and server requests.
The package has an context.Context interface:
type Context interface { Deadline() (deadline time.Time, ok bool) Done() &amp;lt;-chan struct{} Err() error Value(key interface{}) interface{} } The interface provides four functions to observe the context state:</description></item></channel></rss>