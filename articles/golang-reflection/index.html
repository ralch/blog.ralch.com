<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Reflection in Golang | Svetlin Ralchev | Blog</title><meta name=keywords content="go,reflection,metadata"><meta name=description content="What is reflection? In computer science, reflection is the ability of a computer program to examine and modify its own structure and behavior (specifically the values, meta-data, properties and functions) at runtime.
source: Wikipedia
Reflection can be used for observing and modifying program execution at runtime. A reflection-oriented program component can monitor the execution of an enclosure of code and can modify itself according to a desired goal related to that enclosure."><meta name=author content="Svetlin Ralchev"><link rel=canonical href=http://blog.ralch.com/articles/golang-reflection/><link crossorigin=anonymous href=/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://blog.ralch.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://blog.ralch.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://blog.ralch.com/favicon-32x32.png><link rel=apple-touch-icon href=http://blog.ralch.com/apple-touch-icon.png><link rel=mask-icon href=http://blog.ralch.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-62134307-2","auto"),ga("send","pageview"))</script><meta property="og:title" content="Reflection in Golang"><meta property="og:description" content="What is reflection? In computer science, reflection is the ability of a computer program to examine and modify its own structure and behavior (specifically the values, meta-data, properties and functions) at runtime.
source: Wikipedia
Reflection can be used for observing and modifying program execution at runtime. A reflection-oriented program component can monitor the execution of an enclosure of code and can modify itself according to a desired goal related to that enclosure."><meta property="og:type" content="article"><meta property="og:url" content="http://blog.ralch.com/articles/golang-reflection/"><meta property="article:section" content="articles"><meta property="article:published_time" content="2015-12-21T08:15:16+00:00"><meta property="article:modified_time" content="2015-12-21T08:15:16+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Reflection in Golang"><meta name=twitter:description content="What is reflection? In computer science, reflection is the ability of a computer program to examine and modify its own structure and behavior (specifically the values, meta-data, properties and functions) at runtime.
source: Wikipedia
Reflection can be used for observing and modifying program execution at runtime. A reflection-oriented program component can monitor the execution of an enclosure of code and can modify itself according to a desired goal related to that enclosure."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Articles","item":"http://blog.ralch.com/articles/"},{"@type":"ListItem","position":3,"name":"Reflection in Golang","item":"http://blog.ralch.com/articles/golang-reflection/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Reflection in Golang","name":"Reflection in Golang","description":"What is reflection? In computer science, reflection is the ability of a computer program to examine and modify its own structure and behavior (specifically the values, meta-data, properties and functions) at runtime.\nsource: Wikipedia\nReflection can be used for observing and modifying program execution at runtime. A reflection-oriented program component can monitor the execution of an enclosure of code and can modify itself according to a desired goal related to that enclosure.","keywords":["go","reflection","metadata"],"articleBody":"What is reflection? In computer science, reflection is the ability of a computer program to examine and modify its own structure and behavior (specifically the values, meta-data, properties and functions) at runtime.\nsource: Wikipedia\nReflection can be used for observing and modifying program execution at runtime. A reflection-oriented program component can monitor the execution of an enclosure of code and can modify itself according to a desired goal related to that enclosure. This is typically accomplished by dynamically assigning program code at runtime.\nIn Golang reflection allows inspection of struct, interfaces, fields and methods at runtime without knowing the names of the interfaces, fields, methods at compile time. It also allows instantiation of new objects and invocation of methods.\nReflection in action Reflection objects are used for obtaining type information at runtime. The structs that give access to the metadata of a running program are in the reflect package. The package contains structs that allow you to obtain information about the application and to dynamically emits types, values, and objects to the program.\nEven that reflection is not idiomatic for Golang. We will explore in details some of reflect package capabilities.\nExample: QueryBuilder Lets assume that we are developing an object-relation mapping packages like gorm. We will implement QueryBuilder struct that is responsible for generating SQL queries for update, delete and insert.\nThe QueryBuilder has a field Type that keep a metadata information about the type that builder generates SQL queries for:\ntype QueryBuilder struct { Type reflect.Type } Typically the metadata for particular type could be accessed by instaciating the reflect.Type. Lets have the followin struct:\ntype Employee struct { ID uint32 FirstName string LastName string Birthday time.Time } We need to instaciate reflection.Type in order to access its type metadata. It is the representation of a Go type. We should use the following code snippet:\nt := reflect.TypeOf(\u0026Employee{}).Elem() builder := \u0026QueryBuilder{Type: t} Note in case of pointer type, we should retrieve the underlying actual type by getting the result from the Elem function. It panics if the type’s Kind is not Array, Chan, Map, Ptr, or Slice.\nLets inspect the implementation of QueryBuilder function CreateSelectQuery:\nfunc (qb *QueryBuilder) CreateSelectQuery() string { buffer := bytes.NewBufferString(\"\") for index := 0; index \u003c qb.Type.NumField(); index++ { field := qb.Type.Field(index) if index == 0 { buffer.WriteString(\"SELECT \") } else { buffer.WriteString(\", \") } column := field.Name buffer.WriteString(column) } if buffer.Len() \u003e 0 { fmt.Fprintf(buffer, \" FROM %s\", qb.Type.Name()) } return buffer.String() } The type NumField function returns the struct type’s field count. The for-loop interates over that count and obtain every field by index. The type’s Field function returns a StructField value that describes the field owned by the underlying struct:\n// A StructField describes a single field in a struct. type StructField struct { // Name is the field name. // PkgPath is the package path that qualifies a lower case (unexported) // field name. It is empty for upper case (exported) field names. // See https://golang.org/ref/spec#Uniqueness_of_identifiers Name string PkgPath string Type Type // field type Tag StructTag // field tag string Offset uintptr // offset within struct, in bytes Index []int // index sequence for Type.FieldByIndex Anonymous bool // is an embedded field } Then we are appending the field name to the select query. The final implementation produces the following result for Employee struct:\nSELECT ID, FirstName, LastName, Birthday FROM Employee But how to handle the case when our field are represented with different names in underlying database. Lets say that we want to represent ID field as id_pk, FirstName field as first_name and LastName field as last_name.\nWe can implement that kind of mapping by using field tags.\nThe use of tags strongly depends on how your struct is used. A typical use is to add specifications or constraints for persistence or serialisation. For example, when using the JSON parser/encoder, tags are used to specify how the struct will be read from JSON or written in JSON, when the default encoding scheme (i.e. the name of the field) isn’t to be used.\nLets change the Employee struct declaration to use tags that carries additional information about how the field should be mapped into the underlying database:\ntype Employee struct { ID uint32 `orm:\"id_pk\"` FirstName string `orm:\"first_name\"` LastName string `orm:\"last_name\"` Birthday time.Time } Then we can access the associated tags by using field.Tag field. It provides a Get function that allows access to any of the tags by name:\ncolumn := field.Name if tag := field.Tag.Get(\"orm\"); tag != \"\" { column = tag } buffer.WriteString(column) Then the generated select query would be:\nSELECT id_pk, first_name, last_name, Birthday FROM Employee Example: Validating fields In the following example, we will explore how to read and validate fields values. Lets assume that we have the following PaymentTransaction struct:\ntype PaymentTransaction struct { Amount float64 `validate:\"positive\"` Description string `validate:\"max_length:250\"` } Like the previous example, we will use the tag annotation. The implementation of Validate function is the following code snippet:\nfunc Validate(obj interface{}) error { v := reflect.ValueOf(obj).Elem() t := v.Type() for index := 0; index \u003c v.NumField(); index++ { vField := v.Field(index) tField := t.Field(index) tag := tField.Tag.Get(\"validate\") if tag == \"\" { continue } switch vField.Kind() { case reflect.Float64: value := vField.Float() if tag == \"positive\" \u0026\u0026 value \u003c 0 { value = math.Abs(value) vField.SetFloat(value) } case reflect.String: value := vField.String() if tag == \"upper_case\" { value = strings.ToUpper(value) vField.SetString(value) } default: return fmt.Errorf(\"Unsupported kind '%s'\", vField.Kind()) } } return nil } The reflect.Value is the reflection interface to a Go value. It is used to access all member for particular object (fields, function and interfaces). By invoking the Kind function we determine the field type. Then we could access the actual value with the appropriate type function (such as Float or String). To change the field value we should use some of the setters functions.\nExample: Recognising interfaces and calling functions The reflect package can used to identify whether a particular interface is implemented.\nLets have the Validator interface which provide a Validate function called every time when an object is validated:\ntype Validator interface { Validate() error } We will extend the implementation of PaymentTransaction struct by implementing the Validator interface:\nfunc (p *PaymentTransaction) Validate() error { fmt.Println(\"Validating payment transaction\") return nil } In order to determine whether the PaymentTransaction implements the interface, we should call the reflect.Type function Implements. It returns true if the type obeys the interface signature.\nTo call a particular function, we could either case the object to the Validator interface or retrieve the method via MethodByName function:\nfunc CustomValidate(obj interface{ ","wordCount":"1096","inLanguage":"en","datePublished":"2015-12-21T08:15:16Z","dateModified":"2015-12-21T08:15:16Z","author":{"@type":"Person","name":"Svetlin Ralchev"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://blog.ralch.com/articles/golang-reflection/"},"publisher":{"@type":"Organization","name":"Svetlin Ralchev | Blog","logo":{"@type":"ImageObject","url":"http://blog.ralch.com/favicon.ico"}}}</script></head><body id=top><script>window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://blog.ralch.com accesskey=h title="Svetlin Ralchev (Alt + H)"><img src=http://blog.ralch.com/logo.png alt aria-label=logo height=35>Svetlin Ralchev</a><div class=logo-switches></div></div><ul id=menu><li><a href=http://blog.ralch.com/archives title=Archive><span>Archive</span></a></li><li><a href=http://blog.ralch.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=http://blog.ralch.com/categories/ title=Categories><span>Categories</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://blog.ralch.com>Home</a>&nbsp;»&nbsp;<a href=http://blog.ralch.com/articles/>Articles</a></div><h1 class=post-title>Reflection in Golang</h1><div class=post-meta><span title='2015-12-21 08:15:16 +0000 UTC'>December 21, 2015</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Svetlin Ralchev</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#what-is-reflection aria-label="What is reflection?">What is reflection?</a></li><li><a href=#reflection-in-action aria-label="Reflection in action">Reflection in action</a></li><li><a href=#example-querybuilder aria-label="Example: QueryBuilder">Example: QueryBuilder</a></li><li><a href=#example-validating-fields aria-label="Example: Validating fields">Example: Validating fields</a></li><li><a href=#example-recognising-interfaces-and-calling-functions aria-label="Example: Recognising interfaces and calling functions">Example: Recognising interfaces and calling functions</a></li></ul></div></details></div><div class=post-content><h4 id=what-is-reflection>What is reflection?<a hidden class=anchor aria-hidden=true href=#what-is-reflection>#</a></h4><blockquote><p>In computer science, reflection is the ability of a computer program to examine
and modify its own structure and behavior (specifically the values,
meta-data, properties and functions) at runtime.</p></blockquote><p><em>source: <a href=http://bit.ly/1Rpm16G>Wikipedia</a></em></p><p>Reflection can be used for observing and modifying program execution at
runtime. A reflection-oriented program component can monitor the execution of
an enclosure of code and can modify itself according to a desired goal related
to that enclosure. This is typically accomplished by dynamically assigning
program code at runtime.</p><p>In <code>Golang</code> reflection allows inspection of struct, interfaces, fields and
methods at runtime without knowing the names of the interfaces, fields, methods
at compile time. It also allows instantiation of new objects and invocation of
methods.</p><h4 id=reflection-in-action>Reflection in action<a hidden class=anchor aria-hidden=true href=#reflection-in-action>#</a></h4><p>Reflection objects are used for obtaining type information at runtime. The
structs that give access to the metadata of a running program are in the
<code>reflect</code> package. The package contains structs that allow you to obtain
information about the application and to dynamically emits types, values, and
objects to the program.</p><p>Even that reflection is not idiomatic for Golang. We will explore in details some
of <code>reflect</code> package capabilities.</p><h4 id=example-querybuilder>Example: QueryBuilder<a hidden class=anchor aria-hidden=true href=#example-querybuilder>#</a></h4><p>Lets assume that we are developing an object-relation mapping packages like
<a href=https://github.com/jinzhu/gorm>gorm</a>. We will implement <code>QueryBuilder</code> struct
that is responsible for generating <code>SQL</code> queries for update, delete and insert.</p><p>The <code>QueryBuilder</code> has a field <code>Type</code> that keep a metadata information about the
type that builder generates <code>SQL</code> queries for:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>QueryBuilder</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Type</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Type</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Typically the metadata for particular type could be accessed by instaciating the
<code>reflect.Type</code>. Lets have the followin struct:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Employee</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ID</span>        <span style=color:#66d9ef>uint32</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>FirstName</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>LastName</span>  <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Birthday</span>  <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Time</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We need to instaciate <code>reflection.Type</code> in order to access its type metadata.
It is the representation of a Go type. We should use the following code snippet:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>TypeOf</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>Employee</span>{}).<span style=color:#a6e22e>Elem</span>()
</span></span><span style=display:flex><span><span style=color:#a6e22e>builder</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>QueryBuilder</span>{<span style=color:#a6e22e>Type</span>: <span style=color:#a6e22e>t</span>}
</span></span></code></pre></div><p>Note in case of pointer type, we should retrieve the underlying actual type by
getting the result from the <code>Elem</code> function. It panics if the type&rsquo;s
Kind is not Array, Chan, Map, Ptr, or Slice.</p><p>Lets inspect the implementation of <code>QueryBuilder</code> function <code>CreateSelectQuery</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>qb</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>QueryBuilder</span>) <span style=color:#a6e22e>CreateSelectQuery</span>() <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>buffer</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>NewBufferString</span>(<span style=color:#e6db74>&#34;&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>index</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>index</span> &lt; <span style=color:#a6e22e>qb</span>.<span style=color:#a6e22e>Type</span>.<span style=color:#a6e22e>NumField</span>(); <span style=color:#a6e22e>index</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>field</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>qb</span>.<span style=color:#a6e22e>Type</span>.<span style=color:#a6e22e>Field</span>(<span style=color:#a6e22e>index</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>index</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>buffer</span>.<span style=color:#a6e22e>WriteString</span>(<span style=color:#e6db74>&#34;SELECT &#34;</span>)
</span></span><span style=display:flex><span>		} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>buffer</span>.<span style=color:#a6e22e>WriteString</span>(<span style=color:#e6db74>&#34;, &#34;</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>column</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>field</span>.<span style=color:#a6e22e>Name</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>buffer</span>.<span style=color:#a6e22e>WriteString</span>(<span style=color:#a6e22e>column</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>buffer</span>.<span style=color:#a6e22e>Len</span>() &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprintf</span>(<span style=color:#a6e22e>buffer</span>, <span style=color:#e6db74>&#34; FROM %s&#34;</span>, <span style=color:#a6e22e>qb</span>.<span style=color:#a6e22e>Type</span>.<span style=color:#a6e22e>Name</span>())
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>buffer</span>.<span style=color:#a6e22e>String</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The type <code>NumField</code> function returns the struct type&rsquo;s field count. The <code>for-loop</code>
interates over that count and obtain every field by index. The type&rsquo;s <code>Field</code> function
returns a <code>StructField</code> value that describes the field owned by the underlying struct:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#75715e>// A StructField describes a single field in a struct.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>StructField</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Name is the field name.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// PkgPath is the package path that qualifies a lower case (unexported)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// field name.  It is empty for upper case (exported) field names.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// See https://golang.org/ref/spec#Uniqueness_of_identifiers
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>Name</span>    <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>PkgPath</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Type</span>      <span style=color:#a6e22e>Type</span>      <span style=color:#75715e>// field type
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>Tag</span>       <span style=color:#a6e22e>StructTag</span> <span style=color:#75715e>// field tag string
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>Offset</span>    <span style=color:#66d9ef>uintptr</span>   <span style=color:#75715e>// offset within struct, in bytes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>Index</span>     []<span style=color:#66d9ef>int</span>     <span style=color:#75715e>// index sequence for Type.FieldByIndex
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>Anonymous</span> <span style=color:#66d9ef>bool</span>      <span style=color:#75715e>// is an embedded field
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>Then we are appending the field name to the select query. The final implementation
produces the following result for <code>Employee</code> struct:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-SQL data-lang=SQL><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> ID, FirstName, LastName, Birthday <span style=color:#66d9ef>FROM</span> Employee
</span></span></code></pre></div><p>But how to handle the case when our field are represented with different names
in underlying database. Lets say that we want to represent <code>ID</code> field as
<code>id_pk</code>, <code>FirstName</code> field as <code>first_name</code> and <code>LastName</code> field as <code>last_name</code>.</p><p>We can implement that kind of mapping by using <a href=https://golang.org/pkg/reflect/#example_StructTag>field
tags</a>.</p><p>The use of tags strongly depends on how your struct is used. A typical use is
to add specifications or constraints for persistence or serialisation. For
example, when using the <a href=https://golang.org/pkg/encoding/json/>JSON
parser/encoder</a>, tags are used to
specify how the struct will be read from JSON or written in JSON, when the
default encoding scheme (i.e. the name of the field) isn&rsquo;t to be used.</p><p>Lets change the <code>Employee</code> struct declaration to use tags that carries additional
information about how the field should be mapped into the underlying database:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Employee</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ID</span>        <span style=color:#66d9ef>uint32</span> <span style=color:#e6db74>`orm:&#34;id_pk&#34;`</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>FirstName</span> <span style=color:#66d9ef>string</span> <span style=color:#e6db74>`orm:&#34;first_name&#34;`</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>LastName</span>  <span style=color:#66d9ef>string</span> <span style=color:#e6db74>`orm:&#34;last_name&#34;`</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Birthday</span>  <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Time</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Then we can access the associated tags by using <code>field.Tag</code> field. It provides
a <code>Get</code> function that allows access to any of the tags by name:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#a6e22e>column</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>field</span>.<span style=color:#a6e22e>Name</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>tag</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>field</span>.<span style=color:#a6e22e>Tag</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#e6db74>&#34;orm&#34;</span>); <span style=color:#a6e22e>tag</span> <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#34;&#34;</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>column</span> = <span style=color:#a6e22e>tag</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>buffer</span>.<span style=color:#a6e22e>WriteString</span>(<span style=color:#a6e22e>column</span>)
</span></span></code></pre></div><p>Then the generated select query would be:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-SQL data-lang=SQL><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> id_pk, first_name, last_name, Birthday <span style=color:#66d9ef>FROM</span> Employee
</span></span></code></pre></div><h4 id=example-validating-fields>Example: Validating fields<a hidden class=anchor aria-hidden=true href=#example-validating-fields>#</a></h4><p>In the following example, we will explore how to read and validate fields values.
Lets assume that we have the following <code>PaymentTransaction</code> struct:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>PaymentTransaction</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Amount</span>      <span style=color:#66d9ef>float64</span> <span style=color:#e6db74>`validate:&#34;positive&#34;`</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Description</span> <span style=color:#66d9ef>string</span>  <span style=color:#e6db74>`validate:&#34;max_length:250&#34;`</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Like the previous example, we will use the tag annotation. The implementation of
<code>Validate</code> function is the following code snippet:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Validate</span>(<span style=color:#a6e22e>obj</span> <span style=color:#66d9ef>interface</span>{}) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>ValueOf</span>(<span style=color:#a6e22e>obj</span>).<span style=color:#a6e22e>Elem</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>Type</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>index</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>index</span> &lt; <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>NumField</span>(); <span style=color:#a6e22e>index</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>vField</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>Field</span>(<span style=color:#a6e22e>index</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>tField</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Field</span>(<span style=color:#a6e22e>index</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>tag</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>tField</span>.<span style=color:#a6e22e>Tag</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#e6db74>&#34;validate&#34;</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>tag</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;&#34;</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>vField</span>.<span style=color:#a6e22e>Kind</span>() {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Float64</span>:
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>value</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>vField</span>.<span style=color:#a6e22e>Float</span>()
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>tag</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;positive&#34;</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>value</span> &lt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>value</span> = <span style=color:#a6e22e>math</span>.<span style=color:#a6e22e>Abs</span>(<span style=color:#a6e22e>value</span>)
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>vField</span>.<span style=color:#a6e22e>SetFloat</span>(<span style=color:#a6e22e>value</span>)
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>String</span>:
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>value</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>vField</span>.<span style=color:#a6e22e>String</span>()
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>tag</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;upper_case&#34;</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>value</span> = <span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>ToUpper</span>(<span style=color:#a6e22e>value</span>)
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>vField</span>.<span style=color:#a6e22e>SetString</span>(<span style=color:#a6e22e>value</span>)
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>default</span>:
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;Unsupported kind &#39;%s&#39;&#34;</span>, <span style=color:#a6e22e>vField</span>.<span style=color:#a6e22e>Kind</span>())
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>reflect.Value</code> is the reflection interface to a Go value. It is used to
access all member for particular object (fields, function and interfaces). By
invoking the <code>Kind</code> function we determine the field type. Then we could access
the actual value with the appropriate type function (such as <code>Float</code> or <code>String</code>).
To change the field value we should use some of the setters functions.</p><h4 id=example-recognising-interfaces-and-calling-functions>Example: Recognising interfaces and calling functions<a hidden class=anchor aria-hidden=true href=#example-recognising-interfaces-and-calling-functions>#</a></h4><p>The <code>reflect</code> package can used to identify whether a particular interface is
implemented.</p><p>Lets have the <code>Validator</code> interface which provide a <code>Validate</code> function called
every time when an object is validated:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Validator</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Validate</span>() <span style=color:#66d9ef>error</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We will extend the implementation of <code>PaymentTransaction</code> struct by implementing
the <code>Validator</code> interface:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>PaymentTransaction</span>) <span style=color:#a6e22e>Validate</span>() <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Validating payment transaction&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In order to determine whether the <code>PaymentTransaction</code> implements the interface,
we should call the <code>reflect.Type</code> function <code>Implements</code>. It returns <code>true</code> if
the type obeys the interface signature.</p><p>To call a particular function, we could either case the object to the <code>Validator</code>
interface or retrieve the method via <code>MethodByName</code> function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>CustomValidate</span>(<span style=color:#a6e22e>obj</span> <span style=color:#66d9ef>interface</span>{
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=http://blog.ralch.com/tags/go/>go</a></li><li><a href=http://blog.ralch.com/tags/reflection/>reflection</a></li><li><a href=http://blog.ralch.com/tags/metadata/>metadata</a></li></ul><nav class=paginav><a class=prev href=http://blog.ralch.com/articles/golang-proto-buffer/><span class=title>« Prev</span><br><span>Serialization objects with protocol buffers in Golang</span></a>
<a class=next href=http://blog.ralch.com/articles/golang-performance-and-memory-analysis/><span class=title>Next »</span><br><span>Performance and memory analysis of Golang programs</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Reflection in Golang on twitter" href="https://twitter.com/intent/tweet/?text=Reflection%20in%20Golang&amp;url=http%3a%2f%2fblog.ralch.com%2farticles%2fgolang-reflection%2f&amp;hashtags=go%2creflection%2cmetadata"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Reflection in Golang on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2fblog.ralch.com%2farticles%2fgolang-reflection%2f&amp;title=Reflection%20in%20Golang&amp;summary=Reflection%20in%20Golang&amp;source=http%3a%2f%2fblog.ralch.com%2farticles%2fgolang-reflection%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Reflection in Golang on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fblog.ralch.com%2farticles%2fgolang-reflection%2f&title=Reflection%20in%20Golang"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Reflection in Golang on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fblog.ralch.com%2farticles%2fgolang-reflection%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Reflection in Golang on whatsapp" href="https://api.whatsapp.com/send?text=Reflection%20in%20Golang%20-%20http%3a%2f%2fblog.ralch.com%2farticles%2fgolang-reflection%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Reflection in Golang on telegram" href="https://telegram.me/share/url?text=Reflection%20in%20Golang&amp;url=http%3a%2f%2fblog.ralch.com%2farticles%2fgolang-reflection%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>(c) 2023 Svetlin Ralchev</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>