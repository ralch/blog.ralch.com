<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Generics in Golang | Svetlin Ralchev | Blog</title>
<meta name=keywords content="go,generics,code generation">
<meta name=description content="In the article we will take the advantage of [generics] even that they are not first citizen in Go. We will explore gen and genny command line tools.
Gen Gen is a code generation tool that brings some generic query functions. It uses annotations to add this functionality to any structure. The generated code is part of your package and does not have any external dependencies. This approach avoids any reflection and produces an efficient concrete implementation for any annotated type.">
<meta name=author content="Svetlin Ralchev">
<link rel=canonical href=http://blog.ralch.com/articles/golang-code-generation-and-generics/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.5e2b4101351c21e906f398ae96901791830f58d430f96f2659dab7eaef7b3cb7.css integrity="sha256-XitBATUcIekG85iulpAXkYMPWNQw+W8mWdq36u97PLc=" rel="preload stylesheet" as=style>
<link rel=preload href=/logo.png as=image>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://blog.ralch.com/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=http://blog.ralch.com/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=http://blog.ralch.com/favicon-32x32.png>
<link rel=apple-touch-icon href=http://blog.ralch.com/apple-touch-icon.png>
<link rel=mask-icon href=http://blog.ralch.com/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.88.1">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-62134307-2','auto'),ga('send','pageview'))</script><meta property="og:title" content="Generics in Golang">
<meta property="og:description" content="In the article we will take the advantage of [generics] even that they are not first citizen in Go. We will explore gen and genny command line tools.
Gen Gen is a code generation tool that brings some generic query functions. It uses annotations to add this functionality to any structure. The generated code is part of your package and does not have any external dependencies. This approach avoids any reflection and produces an efficient concrete implementation for any annotated type.">
<meta property="og:type" content="article">
<meta property="og:url" content="http://blog.ralch.com/articles/golang-code-generation-and-generics/"><meta property="article:section" content="articles">
<meta property="article:published_time" content="2015-10-18T05:00:00+01:00">
<meta property="article:modified_time" content="2015-10-18T05:00:00+01:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Generics in Golang">
<meta name=twitter:description content="In the article we will take the advantage of [generics] even that they are not first citizen in Go. We will explore gen and genny command line tools.
Gen Gen is a code generation tool that brings some generic query functions. It uses annotations to add this functionality to any structure. The generated code is part of your package and does not have any external dependencies. This approach avoids any reflection and produces an efficient concrete implementation for any annotated type.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Articles","item":"http://blog.ralch.com/articles/"},{"@type":"ListItem","position":3,"name":"Generics in Golang","item":"http://blog.ralch.com/articles/golang-code-generation-and-generics/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Generics in Golang","name":"Generics in Golang","description":"In the article we will take the advantage of [generics] even that they are not first citizen in Go. We will explore gen and genny command line tools.\nGen Gen is a code generation tool that brings some generic query functions. It uses annotations to add this functionality to any structure. The generated code is part of your package and does not have any external dependencies. This approach avoids any reflection and produces an efficient concrete implementation for any annotated type.","keywords":["go","generics","code generation"],"articleBody":"In the article we will take the advantage of [generics] even that they are not first citizen in Go. We will explore gen and genny command line tools.\nGen Gen is a code generation tool that brings some generic query functions. It uses annotations to add this functionality to any structure. The generated code is part of your package and does not have any external dependencies. This approach avoids any reflection and produces an efficient concrete implementation for any annotated type.\nBy default the package generates various query functions. They can be used to project, filter, sort and group slices of the annotated types.\nInstallation We should use go get command to install gen:\n$ go get clipperhouse.github.io/gen Usage As any other Go generation tool, Gen requires a specific annoation comment declared before the desired type declaration.\n// +gen [*] tag:\"Value, Value[T,T]\" anothertag type AnnotatedType It begins with the +gen directive. Optionally it is followed by a [*], indicating that the generated type should be a pointer. Tags and values are interpreted by the available type writers. They are responsible for the actual code generation. We will learn more about them in the next section. For now we will use the default slice type writer.\nLets use it to generate functions for filtering, distincting, sorting and projecting a Company struct:\n// filename: company.go package company // +gen slice:\"Where,GroupBy[string],DistinctBy,SortBy,Select[string]\" type Company struct { Name string Country string City string } After declaring the type annoation, we should execute gen:\n$ gen It produces comapany_slice.go file that contains the concrete implementation for any listed function in the comment.\nLets use the generated functions with the following slice:\ncompanies := company.CompanySlice{ company.Company{Name: \"Microsoft\", Country: \"USA\", City: \"Redmond\"}, company.Company{Name: \"Google\", Country: \"USA\", City: \"Palo Alto\"}, company.Company{Name: \"Facebook\", Country: \"USA\", City: \"Palo Alto\"}, company.Company{Name: \"Uber\", Country: \"USA\", City: \"San Francisco\"}, company.Company{Name: \"Tweeter\", Country: \"USA\", City: \"San Francisco\"}, company.Company{Name: \"SoundCloud\", Country: \"Germany\", City: \"Berlin\"}, } Lets get all companies that are based on USA. For that you should use the Where function, which receives predicate function as an argument.\nThe clojure function receives a company object as argument and returns boolean value. It is executed for every item in the slice. It should retun true for all objects that meets our criteria:\nallUSCompanies := companies.Where(func(comp company.Company) bool { return comp.Country == \"USA\" }) If we distinct all companies by their country of origin, we should use the DistinctBy function that uses a function that checks two company objects for equaty:\nuniqueCompanies := companies.DistinctBy(func(compA company.Company, compB company.Company) bool { return compA.Country == compB.Country }) If we want to sort the companies by their name, we should use SortBy function that receives as an argument a function that determines whether its first argument is less that second one:\n// In our case we can use strings.Compare to compare to strings. It returns -1 // the first string is less than the second. sortedCompanies := companies.SortBy(func(compA company.Company, compB company.Company) bool { return strings.Compare(compA.Name, compB.Name) == -1 }) If we want to group the companies by their country of residence, we can use GroupByString function that returns a map[string]company.CompanySlice object. The key of every entry is determined by its clojure function.\ngroupedCompanies := companies.GroupByString(func(comp company.Company) string { return comp.Country }) fmt.Println(\"US Companies: \", groupedCompanies[\"USA\"]) fmt.Println(\"German Companies: \", groupedCompanies[\"Germany\"]) The company slice can be projected as a string by using generated Select function. The following code snippet projects the list of companies as a list of company names:\ncompanyNames := companies.SelectString(func(comp company.Company) string { return comp.Name }) fmt.Println(companyNames) // This slice of strings is produced by the code snippet [Microsoft Google Facebook Uber Tweeter SoundCloud] A great Gen feature is that most of the functions can be chained. Lets select all companies based in USA then order them by their name and format their name in the following format:\n%COMPANY_NAME% is based in %CITY% We can simply chain Where, SortBy and SelectString functions:\nresult := companies.Where(func(comp company.Company) bool { return comp.Country == \"USA\" }).SortBy(func(compA company.Company, compB company.Company) bool { return strings.Compare(compA.Name, compB.Name) == -1 }).SelectString(func(comp company.Company) string { return fmt.Sprintf(\"%s's is based in %s\", comp.Name, comp.City) }) for _, text := range result { fmt.Println(text) } You can read more about another auxiliary function in the official documentation.\nImplementing a type writer The type writers are responsible for interpreting the annotated tags and generating go code. They are implementing the following interface:\ntype Interface interface { Name() string Imports(t Type) []ImportSpec Write(w io.Writer, t Type) error }  Name returns the writer’s name Imports function returns a slice of packages that are required and written as imports in the generated file Write function writes the actual generated code  Lets implement a writer that generates the Stack data structure. Gen uses text/template as a templating format.\n// A structure that represents a stack data structure // for {{.Name}} type // // Example: // stack := \u0026stack.Stack{} // stack.Push(new(TValue)) // value, err := stack.Pop() type {{.Name}}Stack struct { data []{{.Pointer}}{{.Name}} } // Adds an element on top of the stack func (s *{{.Name}}Stack) Push(value {{.Pointer}}{{.Name}}) { s.data = append(s.data, value) } // Removes an element from top of the stack. // If the stack is empty, it returns an error. func (s *{{.Name}}Stack) Pop() ({{.Pointer}}{{.Name}}, error) { length := len(s.data) if length == 0 { return nil, errors.New(\"Stack is empty\") } value := s.data[length-1] s.data = s.data[:length-1] return value, nil } The template declared by typewriter.Template instance. The templateContent variable contains the actual text/template string:\n// filename: templates.go package stack import \"github.com/clipperhouse/typewriter\" var templates = typewriter.TemplateSlice{ stackTmpl, } var stackTmpl = \u0026typewriter.Template{ Name: \"Stack\", Text: templateContent, } The following structure implements a type writer responsible for code generation of declared template:\n// filename: stack.go package stack import ( \"io\" \"github.com/clipperhouse/typewriter\" ) func init() { if err := typewriter.Register(NewWriter()); err != nil { panic(err) } } type writer struct{} // Creates a new stack type writer func NewWriter() typewriter.Interface { return \u0026writer{} } func (tw *writer) Name() string { return \"stack\" } func (tw *writer) Imports(t typewriter.Type) (result []typewriter.ImportSpec) { return } func (tw *writer) Write(w io.Writer, t typewriter.Type) error { // retrieve that for this type writer a tag is declared in the annoation // if it's not found the writer won't be generate anything tag, found := t.FindTag(tw) if !found { return nil } // Write a header commend in the generated file header := \"// DO NOT MODIFY. Auto-generated code.\" if _, err := w.Write([]byte(header)); err != nil { return err } // A template for the exact tag is retrieved tmpl, err := templates.ByTag(t, tag) if err != nil { return err } // Write out the template substitution to the writer if err := tmpl.Execute(w, t); err != nil { return err } return nil } In ored to use the template we should declare annotation. Lets annotate company.Company struct:\n// +gen * stack type Company struct { Name string Country string City string } After executing $ gen command a company_stack.go file is placed in the package directory. It contains an actual implementation of CompanyStack structure, which can be used in the following way:\nstack := \u0026StudentStack{} stack.Push(\u0026Student{FirstName: \"John\", LastName: \"Smith\"}) student, err := stack.Pop() A complete implementation of the custom type writer can be pulled from this repository.\nGenny Genny is a code-generation tool that replaces usage of generics. It allows to transform a Go source code into specific implementation by replacing its generic types.\nInstallation Install by executing go get:\n$ go get github.com/cheekybits/genny Usage The tool uses a similar approach as gotemplate. A special comment should be provided in order to be recognised by go generate:\n//go:generate genny -in=$GOFILE -out=gen-$GOFILE gen \"KeyType=string,int ValueType=string,int\" Parameters:\n -in specifies the input file (template) -out specifies the output file $GOFILE refers to the current file KeyType and ValueType are the parameter names in the specified template  As the other tools, we should just call go generate to produce a file that is result of substition between the template and provided parameters.\nDeclaring generics The template can contains as many as we require parameters. They should be defined using the special genny type generic.Type:\ntype KeyType generic.Type type ValueType generic.Type Lets port the Stack data struct in genny:\n//go:generate genny -in=$GOFILE -out=gen-$GOFILE gen \"ValueType=*Student\" type ValueType generic.Type type Stack struct { data []ValueType } func (s *Stack) Push(value TValueType) { s.data = append(s.data, value) } func (s *Stack) Pop() (TValueType, error) { length := len(s.data) if length == 0 { return nil, errors.New(\"Stack is empty\") } value := s.data[length-1] s.data = s.data[:length-1] return value, nil } Significant difference from gotemplate is that in genny the special go:generate comment should be placed in the actual template. This can be avoid by executing genny from the command line shell:\n$ cat ./stack.go | genny gen \"ValueType=*Student\"  student_stack.go Conclusion Do you still complain that Go does not support generics?\nGen and genny are great tools for automating a common development tasks. Because of their template nature, we can focus on what should be generated instead of how to generate it.\n","wordCount":"1507","inLanguage":"en","datePublished":"2015-10-18T05:00:00+01:00","dateModified":"2015-10-18T05:00:00+01:00","author":{"@type":"Person","name":"Svetlin Ralchev"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://blog.ralch.com/articles/golang-code-generation-and-generics/"},"publisher":{"@type":"Organization","name":"Svetlin Ralchev | Blog","logo":{"@type":"ImageObject","url":"http://blog.ralch.com/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=http://blog.ralch.com accesskey=h title="Svetlin Ralchev (Alt + H)">
<img src=/logo.png alt=logo aria-label=logo height=35>Svetlin Ralchev</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=http://blog.ralch.com/archives title=Archive>
<span>Archive</span>
</a>
</li>
<li>
<a href=http://blog.ralch.com/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
<li>
<a href=http://blog.ralch.com/categories/ title=Categories>
<span>Categories</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=http://blog.ralch.com>Home</a>&nbsp;»&nbsp;<a href=http://blog.ralch.com/articles/>Articles</a></div>
<h1 class=post-title>
Generics in Golang
</h1>
<div class=post-meta>October 18, 2015&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Svetlin Ralchev
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#gen aria-label=Gen>Gen</a><ul>
<li>
<a href=#installation aria-label=Installation>Installation</a></li>
<li>
<a href=#usage aria-label=Usage>Usage</a></li>
<li>
<a href=#implementing-a-type-writer aria-label="Implementing a type writer">Implementing a type writer</a></li></ul>
</li>
<li>
<a href=#genny aria-label=Genny>Genny</a><ul>
<li>
<a href=#installation-1 aria-label=Installation>Installation</a></li>
<li>
<a href=#usage-1 aria-label=Usage>Usage</a></li></ul>
</li>
<li>
<a href=#declaring-generics aria-label="Declaring generics">Declaring generics</a></li>
<li>
<a href=#conclusion aria-label=Conclusion>Conclusion</a>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><p>In the article we will take the advantage of [generics] even that they are not
first citizen in <code>Go</code>. We will explore <a href=http://clipperhouse.github.io/gen>gen</a> and
<a href=https://github.com/cheekybits/genny>genny</a> command line tools.</p>
<h3 id=gen>Gen<a hidden class=anchor aria-hidden=true href=#gen>#</a></h3>
<p><code>Gen</code> is a code generation tool that brings some generic query functions. It uses
annotations to add this functionality to any structure. The generated code is
part of your package and does not have any external dependencies. This approach
avoids any reflection and produces an efficient concrete implementation for any
annotated type.</p>
<p>By default the package generates various query functions. They can be used to
project, filter, sort and group slices of the annotated types.</p>
<h4 id=installation>Installation<a hidden class=anchor aria-hidden=true href=#installation>#</a></h4>
<p>We should use <code>go get</code> command to install <code>gen</code>:</p>
<pre tabindex=0><code>$ go get clipperhouse.github.io/gen 
</code></pre><h4 id=usage>Usage<a hidden class=anchor aria-hidden=true href=#usage>#</a></h4>
<p>As any other <code>Go</code> generation tool, <code>Gen</code> requires a specific annoation comment
declared before the desired type declaration.</p>
<pre tabindex=0><code>// +gen [*] tag:&quot;Value, Value[T,T]&quot; anothertag
type AnnotatedType
</code></pre><p>It begins with the <code>+gen</code> directive. Optionally it is followed by a <code>[*]</code>,
indicating that the generated type should be a pointer. Tags and values are
interpreted by the available type writers. They are responsible for the actual
code generation. We will learn more about them in the next section. For now we
will use the default slice type writer.</p>
<p>Lets use it to generate functions for filtering, distincting, sorting and projecting
a <code>Company</code> struct:</p>
<pre tabindex=0><code>// filename: company.go
package company

// +gen slice:&quot;Where,GroupBy[string],DistinctBy,SortBy,Select[string]&quot;
type Company struct {
	Name    string
	Country string
	City    string
}
</code></pre><p>After declaring the type annoation, we should execute <code>gen</code>:</p>
<pre tabindex=0><code>$ gen
</code></pre><p>It produces <code>comapany_slice.go</code> file that contains the concrete implementation
for any listed function in the comment.</p>
<p>Lets use the generated functions with the following slice:</p>
<pre tabindex=0><code>companies := company.CompanySlice{
	company.Company{Name: &quot;Microsoft&quot;, Country: &quot;USA&quot;, City: &quot;Redmond&quot;},
	company.Company{Name: &quot;Google&quot;, Country: &quot;USA&quot;, City: &quot;Palo Alto&quot;},
	company.Company{Name: &quot;Facebook&quot;, Country: &quot;USA&quot;, City: &quot;Palo Alto&quot;},
	company.Company{Name: &quot;Uber&quot;, Country: &quot;USA&quot;, City: &quot;San Francisco&quot;},
	company.Company{Name: &quot;Tweeter&quot;, Country: &quot;USA&quot;, City: &quot;San Francisco&quot;},
	company.Company{Name: &quot;SoundCloud&quot;, Country: &quot;Germany&quot;, City: &quot;Berlin&quot;},
}
</code></pre><p>Lets get all companies that are based on USA. For that you should use the <code>Where</code>
function, which receives predicate function as an argument.</p>
<p>The clojure function receives a company object as argument and returns
boolean value. It is executed for every item in the slice. It should retun
<code>true</code> for all objects that meets our criteria:</p>
<pre tabindex=0><code>allUSCompanies := companies.Where(func(comp company.Company) bool {
	return comp.Country == &quot;USA&quot;
})
</code></pre><p>If we distinct all companies by their country of origin, we should use the
<code>DistinctBy</code> function that uses a function that checks two company objects
for equaty:</p>
<pre tabindex=0><code>uniqueCompanies := companies.DistinctBy(func(compA company.Company, compB company.Company) bool {
	return compA.Country == compB.Country
})
</code></pre><p>If we want to sort the companies by their name, we should use <code>SortBy</code> function
that receives as an argument a function that determines whether its first argument
is less that second one:</p>
<pre tabindex=0><code>// In our case we can use strings.Compare to compare to strings. It returns -1
// the first string is less than the second.
sortedCompanies := companies.SortBy(func(compA company.Company, compB company.Company) bool {
	return strings.Compare(compA.Name, compB.Name) == -1
})
</code></pre><p>If we want to group the companies by their country of residence, we can use
<code>GroupByString</code> function that returns a <code>map[string]company.CompanySlice</code> object.
The key of every entry is determined by its clojure function.</p>
<pre tabindex=0><code>groupedCompanies := companies.GroupByString(func(comp company.Company) string {
	return comp.Country
})

fmt.Println(&quot;US Companies: &quot;, groupedCompanies[&quot;USA&quot;])
fmt.Println(&quot;German Companies: &quot;, groupedCompanies[&quot;Germany&quot;])
</code></pre><p>The company slice can be projected as a string by using generated <code>Select</code>
function. The following code snippet projects the list of companies as a list
of company names:</p>
<pre tabindex=0><code>companyNames := companies.SelectString(func(comp company.Company) string {
	return comp.Name
})

fmt.Println(companyNames)
</code></pre><pre tabindex=0><code>// This slice of strings is produced by the code snippet
[Microsoft Google Facebook Uber Tweeter SoundCloud]
</code></pre><p>A great <code>Gen</code> feature is that most of the functions can be chained. Lets select
all companies based in USA then order them by their name and format their name
in the following format:</p>
<pre tabindex=0><code>%COMPANY_NAME% is based in %CITY%
</code></pre><p>We can simply chain <code>Where</code>, <code>SortBy</code> and <code>SelectString</code> functions:</p>
<pre tabindex=0><code>result := companies.Where(func(comp company.Company) bool {
	return comp.Country == &quot;USA&quot;
}).SortBy(func(compA company.Company, compB company.Company) bool {
	return strings.Compare(compA.Name, compB.Name) == -1
}).SelectString(func(comp company.Company) string {
	return fmt.Sprintf(&quot;%s's is based in %s&quot;, comp.Name, comp.City)
})

for _, text := range result {
	fmt.Println(text)
}
</code></pre><p>You can read more about another auxiliary function in the <a href=http://clipperhouse.github.io/gen/slice/>official documentation</a>.</p>
<h4 id=implementing-a-type-writer>Implementing a type writer<a hidden class=anchor aria-hidden=true href=#implementing-a-type-writer>#</a></h4>
<p>The type writers are responsible for interpreting the annotated tags and
generating go code. They are implementing the following interface:</p>
<pre tabindex=0><code>type Interface interface {
	Name() string
	Imports(t Type) []ImportSpec
	Write(w io.Writer, t Type) error
}
</code></pre><ul>
<li><code>Name</code> returns the writer&rsquo;s name</li>
<li><code>Imports</code> function returns a slice of packages that are required and written
as imports in the generated file</li>
<li><code>Write</code> function writes the actual generated code</li>
</ul>
<p>Lets implement a writer that generates the <code>Stack</code> data structure. <code>Gen</code> uses
<a href=https://golang.org/pkg/text/template/>text/template</a> as a templating format.</p>
<pre tabindex=0><code>// A structure that represents a stack data structure
// for {{.Name}} type
//
// Example:
// stack := &amp;stack.Stack{}
// stack.Push(new(TValue))
// value, err := stack.Pop()
type {{.Name}}Stack struct {
	data []{{.Pointer}}{{.Name}}
}

// Adds an element on top of the stack
func (s *{{.Name}}Stack) Push(value {{.Pointer}}{{.Name}}) {
	s.data = append(s.data, value)
}

// Removes an element from top of the stack.
// If the stack is empty, it returns an error.
func (s *{{.Name}}Stack) Pop() ({{.Pointer}}{{.Name}}, error) {
	length := len(s.data)
	if length == 0 {
		return nil, errors.New(&quot;Stack is empty&quot;)
	}

	value := s.data[length-1]
	s.data = s.data[:length-1]
	return value, nil
}
</code></pre><p>The template declared by <code>typewriter.Template</code> instance. The <code>templateContent</code>
variable contains the actual <code>text/template</code> string:</p>
<pre tabindex=0><code>// filename: templates.go
package stack

import &quot;github.com/clipperhouse/typewriter&quot;

var templates = typewriter.TemplateSlice{
	stackTmpl,
}

var stackTmpl = &amp;typewriter.Template{
	Name: &quot;Stack&quot;,
	Text: templateContent,
}
</code></pre><p>The following structure implements a type writer responsible for code generation
of declared template:</p>
<pre tabindex=0><code>// filename: stack.go
package stack

import (
	&quot;io&quot;

	&quot;github.com/clipperhouse/typewriter&quot;
)

func init() {
	if err := typewriter.Register(NewWriter()); err != nil {
		panic(err)
	}
}

type writer struct{}

// Creates a new stack type writer
func NewWriter() typewriter.Interface {
	return &amp;writer{}
}

func (tw *writer) Name() string {
	return &quot;stack&quot;
}

func (tw *writer) Imports(t typewriter.Type) (result []typewriter.ImportSpec) {
	return
}

func (tw *writer) Write(w io.Writer, t typewriter.Type) error {
  // retrieve that for this type writer a tag is declared in the annoation
	// if it's not found the writer won't be generate anything
	tag, found := t.FindTag(tw)

	if !found {
		return nil
	}

  // Write a header commend in the generated file
	header := &quot;// DO NOT MODIFY. Auto-generated code.&quot;
	if _, err := w.Write([]byte(header)); err != nil {
		return err
	}
	
	// A template for the exact tag is retrieved
	tmpl, err := templates.ByTag(t, tag)
	if err != nil {
		return err
	}

  // Write out the template substitution to the writer
	if err := tmpl.Execute(w, t); err != nil {
		return err
	}
	return nil
}
</code></pre><p>In ored to use the template we should declare annotation. Lets annotate
<code>company.Company</code> struct:</p>
<pre tabindex=0><code>// +gen * stack
type Company struct {
	Name    string
	Country string
	City    string
}
</code></pre><p>After executing <code>$ gen</code> command a <code>company_stack.go</code> file is placed in the package
directory. It contains an actual implementation of <code>CompanyStack</code> structure,
which can be used in the following way:</p>
<pre tabindex=0><code>stack := &amp;StudentStack{}
stack.Push(&amp;Student{FirstName: &quot;John&quot;, LastName: &quot;Smith&quot;})
student, err := stack.Pop()
</code></pre><p>A complete implementation of the custom type writer can be pulled from
<a href=https://github.com/iamralch/gen>this repository</a>.</p>
<h3 id=genny>Genny<a hidden class=anchor aria-hidden=true href=#genny>#</a></h3>
<p><code>Genny</code> is a code-generation tool that replaces usage of generics. It allows
to transform a Go source code into specific implementation by replacing its
generic types.</p>
<h4 id=installation-1>Installation<a hidden class=anchor aria-hidden=true href=#installation-1>#</a></h4>
<p>Install by executing <code>go get</code>:</p>
<pre tabindex=0><code>$ go get github.com/cheekybits/genny
</code></pre><h4 id=usage-1>Usage<a hidden class=anchor aria-hidden=true href=#usage-1>#</a></h4>
<p>The tool uses a similar approach as <code>gotemplate</code>. A special comment should be
provided in order to be recognised by <code>go generate</code>:</p>
<pre tabindex=0><code>//go:generate genny -in=$GOFILE -out=gen-$GOFILE gen &quot;KeyType=string,int ValueType=string,int&quot;
</code></pre><p>Parameters:</p>
<ul>
<li><code>-in</code> specifies the input file (template)</li>
<li><code>-out</code> specifies the output file</li>
<li><code>$GOFILE</code> refers to the current file</li>
<li><code>KeyType</code> and <code>ValueType</code> are the parameter names in the specified template</li>
</ul>
<p>As the other tools, we should just call <code>go generate</code> to produce a file that is
result of substition between the template and provided parameters.</p>
<h3 id=declaring-generics>Declaring generics<a hidden class=anchor aria-hidden=true href=#declaring-generics>#</a></h3>
<p>The template can contains as many as we require parameters. They should be defined
using the special genny type <code>generic.Type</code>:</p>
<pre tabindex=0><code>type KeyType generic.Type
type ValueType generic.Type
</code></pre><p>Lets port the <code>Stack</code> data struct in <code>genny</code>:</p>
<pre tabindex=0><code>//go:generate genny -in=$GOFILE -out=gen-$GOFILE gen &quot;ValueType=*Student&quot;
type ValueType generic.Type

type Stack struct {
	data []ValueType
}

func (s *Stack) Push(value TValueType) {
	s.data = append(s.data, value)
}

func (s *Stack) Pop() (TValueType, error) {
	length := len(s.data)
	if length == 0 {
		return nil, errors.New(&quot;Stack is empty&quot;)
	}

	value := s.data[length-1]
	s.data = s.data[:length-1]
	return value, nil
}
</code></pre><p>Significant difference from <code>gotemplate</code> is that in <code>genny</code> the special <code>go:generate</code>
comment should be placed in the actual template. This can be avoid by executing
<code>genny</code> from the command line shell:</p>
<pre tabindex=0><code>$ cat ./stack.go | genny gen &quot;ValueType=*Student&quot; &gt; student_stack.go
</code></pre><h3 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h3>
<p>Do you still complain that <code>Go</code> does not support generics?</p>
<p><code>Gen</code> and <code>genny</code> are great tools for automating a common development tasks. Because of their
template nature, we can focus on what should be generated instead of how to generate it.</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=http://blog.ralch.com/tags/go/>go</a></li>
<li><a href=http://blog.ralch.com/tags/generics/>generics</a></li>
<li><a href=http://blog.ralch.com/tags/code-generation/>code generation</a></li>
</ul>
<nav class=paginav>
<a class=prev href=http://blog.ralch.com/articles/golang-query-data-with-linq/>
<span class=title>« Prev Page</span>
<br>
<span>Query data with Golang and LINQ</span>
</a>
<a class=next href=http://blog.ralch.com/articles/golang-code-generation-with-gotemplates/>
<span class=title>Next Page »</span>
<br>
<span>Reusing source code with Go templates</span>
</a>
</nav>
<div class=share-buttons>
<a target=_blank rel="noopener noreferrer" aria-label="share Generics in Golang on twitter" href="https://twitter.com/intent/tweet/?text=Generics%20in%20Golang&url=http%3a%2f%2fblog.ralch.com%2farticles%2fgolang-code-generation-and-generics%2f&hashtags=go%2cgenerics%2ccodegeneration"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Generics in Golang on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=http%3a%2f%2fblog.ralch.com%2farticles%2fgolang-code-generation-and-generics%2f&title=Generics%20in%20Golang&summary=Generics%20in%20Golang&source=http%3a%2f%2fblog.ralch.com%2farticles%2fgolang-code-generation-and-generics%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Generics in Golang on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fblog.ralch.com%2farticles%2fgolang-code-generation-and-generics%2f&title=Generics%20in%20Golang"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Generics in Golang on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fblog.ralch.com%2farticles%2fgolang-code-generation-and-generics%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Generics in Golang on whatsapp" href="https://api.whatsapp.com/send?text=Generics%20in%20Golang%20-%20http%3a%2f%2fblog.ralch.com%2farticles%2fgolang-code-generation-and-generics%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Generics in Golang on telegram" href="https://telegram.me/share/url?text=Generics%20in%20Golang&url=http%3a%2f%2fblog.ralch.com%2farticles%2fgolang-code-generation-and-generics%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg>
</a>
</div>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2021 <a href=http://blog.ralch.com>Svetlin Ralchev | Blog</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>